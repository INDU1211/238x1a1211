// lib/main.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

/// IMPORTANT: If you created firebase_options.dart via the FlutterFire CLI,
/// you can import and use DefaultFirebaseOptions.currentPlatform in Firebase.initializeApp.
/// For simplicity in this single-file example we call Firebase.initializeApp() without options,
/// but in real projects you'll likely supply generated options (esp. for web).
///
/// If you use the FlutterFire CLI, replace the Firebase.initializeApp() call below with:
/// await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  runApp(const MyApp());
}

class AuthState extends ChangeNotifier {
  User? user;
  AuthState() {
    FirebaseAuth.instance.authStateChanges().listen((u) {
      user = u;
      notifyListeners();
    });
  }

  Future<void> signOut() => FirebaseAuth.instance.signOut();
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (_) => AuthState(),
      child: MaterialApp(
        title: 'Get It Done (Firebase)',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          useMaterial3: true,
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo),
        ),
        home: const RootPage(),
      ),
    );
  }
}

class RootPage extends StatelessWidget {
  const RootPage({super.key});
  @override
  Widget build(BuildContext context) {
    final auth = Provider.of<AuthState>(context);
    // Show loading before auth resolves
    if (auth.user == null) {
      // There are two states with user==null: not signed in OR still initializing.
      // But our listener runs quickly; show auth screens if null.
      return const AuthScreen();
    } else {
      return HomeScreen(user: auth.user!);
    }
  }
}

/// ------------------------
/// Authentication Screens
/// ------------------------
class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});
  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  bool isLogin = true;
  final _formKey = GlobalKey<FormState>();
  String email = '';
  String password = '';
  String displayName = '';
  bool loading = false;
  String? error;

  Future<void> submit() async {
    final form = _formKey.currentState!;
    if (!form.validate()) return;
    form.save();
    setState(() {
      loading = true;
      error = null;
    });

    try {
      if (isLogin) {
        await FirebaseAuth.instance.signInWithEmailAndPassword(
          email: email.trim(),
          password: password,
        );
      } else {
        final cred =
            await FirebaseAuth.instance.createUserWithEmailAndPassword(
          email: email.trim(),
          password: password,
        );
        // Update display name (optional)
        if (displayName.isNotEmpty) {
          await cred.user?.updateDisplayName(displayName.trim());
        }
        // Optionally create a user doc in Firestore (not required for this app)
        await FirebaseFirestore.instance
            .collection('users')
            .doc(cred.user!.uid)
            .set({
          'email': email.trim(),
          'displayName': displayName.trim(),
          'createdAt': FieldValue.serverTimestamp(),
        });
      }
    } on FirebaseAuthException catch (e) {
      setState(() {
        error = e.message;
      });
    } catch (e) {
      setState(() {
        error = e.toString();
      });
    } finally {
      if (mounted) {
        setState(() {
          loading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final toggleText = isLogin ? "Don't have an account? Sign up" : "Already have an account? Log in";
    return Scaffold(
      appBar: AppBar(title: const Text('Get It Done — Sign in')),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Card(
            elevation: 6,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            child: Padding(
              padding: const EdgeInsets.all(18),
              child: Form(
                key: _formKey,
                child: Column(mainAxisSize: MainAxisSize.min, children: [
                  Text(isLogin ? 'Welcome back' : 'Create account',
                      style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 12),
                  if (!isLogin)
                    TextFormField(
                      decoration: const InputDecoration(labelText: 'Display name (optional)'),
                      onSaved: (v) => displayName = v ?? '',
                    ),
                  TextFormField(
                    decoration: const InputDecoration(labelText: 'Email'),
                    keyboardType: TextInputType.emailAddress,
                    validator: (v) {
                      if (v == null || v.trim().isEmpty) return 'Enter email';
                      if (!v.contains('@')) return 'Enter valid email';
                      return null;
                    },
                    onSaved: (v) => email = v ?? '',
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    decoration: const InputDecoration(labelText: 'Password'),
                    obscureText: true,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Enter password';
                      if (v.length < 6) return 'Min 6 chars';
                      return null;
                    },
                    onSaved: (v) => password = v ?? '',
                  ),
                  const SizedBox(height: 12),
                  if (error != null) ...[
                    Text(error!, style: const TextStyle(color: Colors.red)),
                    const SizedBox(height: 8),
                  ],
                  ElevatedButton.icon(
                    onPressed: loading ? null : submit,
                    icon: loading ? const CircularProgressIndicator.adaptive() : const Icon(Icons.check),
                    label: Text(isLogin ? 'Log in' : 'Sign up'),
                  ),
                  TextButton(
                    onPressed: () => setState(() => isLogin = !isLogin),
                    child: Text(toggleText),
                  )
                ]),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// ------------------------
/// Home screen (task list)
/// ------------------------
class HomeScreen extends StatelessWidget {
  final User user;
  const HomeScreen({required this.user, super.key});

  @override
  Widget build(BuildContext context) {
    final tasksQuery = FirebaseFirestore.instance
        .collection('tasks')
        .where('uid', isEqualTo: user.uid)
        .orderBy('createdAt', descending: true);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Get It Done'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Sign out',
            onPressed: () async {
              await FirebaseAuth.instance.signOut();
            },
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => showDialog(
          context: context,
          builder: (_) => TaskDialog(uid: user.uid),
        ),
      ),
      body: Column(
        children: [
          _UserHeader(user: user),
          Expanded(
            child: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
              stream: tasksQuery.snapshots(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
                  return const Center(child: Text('No tasks yet — add one!'));
                }
                final docs = snapshot.data!.docs;
                return ListView.builder(
                  padding: const EdgeInsets.symmetric(vertical: 8),
                  itemCount: docs.length,
                  itemBuilder: (context, index) {
                    final doc = docs[index];
                    final data = doc.data();
                    return TaskTile(
                      id: doc.id,
                      uid: data['uid'] as String? ?? '',
                      title: data['title'] ?? '',
                      note: data['note'] ?? '',
                      done: data['done'] ?? false,
                      timestamp: (data['createdAt'] as Timestamp?)?.toDate(),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class _UserHeader extends StatelessWidget {
  final User user;
  const _UserHeader({required this.user, super.key});
  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(child: Text(user.email?.substring(0,1).toUpperCase() ?? '?')),
      title: Text(user.displayName?.isNotEmpty == true ? user.displayName! : user.email ?? 'User'),
      subtitle: Text(user.email ?? ''),
    );
  }
}

/// ------------------------
/// Task tile and actions
/// ------------------------
class TaskTile extends StatelessWidget {
  final String id;
  final String uid;
  final String title;
  final String note;
  final bool done;
  final DateTime? timestamp;

  const TaskTile({
    required this.id,
    required this.uid,
    required this.title,
    required this.note,
    required this.done,
    this.timestamp,
    super.key,
  });

  Future<void> toggleDone() async {
    await FirebaseFirestore.instance.collection('tasks').doc(id).update({'done': !done});
  }

  Future<void> deleteTask(BuildContext context) async {
    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Delete task?'),
        content: const Text('This will remove the task permanently.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancel')),
          ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text('Delete')),
        ],
      ),
    );
    if (ok == true) {
      await FirebaseFirestore.instance.collection('tasks').doc(id).delete();
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Task deleted')));
      }
    }
  }

  Future<void> editTask(BuildContext context) async {
    showDialog(
      context: context,
      builder: (_) => TaskDialog(
        uid: uid,
        taskId: id,
        initialTitle: title,
        initialNote: note,
        initialDone: done,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final created = timestamp != null ? '${timestamp!.toLocal()}' : '';
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: ListTile(
        onTap: () => editTask(context),
        leading: Checkbox(value: done, onChanged: (_) => toggleDone()),
        title: Text(
          title,
          style: TextStyle(decoration: done ? TextDecoration.lineThrough : null),
        ),
        subtitle: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          if (note.isNotEmpty) Text(note),
          if (created.isNotEmpty) const SizedBox(height: 6),
          if (created.isNotEmpty) Text(created, style: const TextStyle(fontSize: 11)),
        ]),
        trailing: IconButton(icon: const Icon(Icons.delete), onPressed: () => deleteTask(context)),
      ),
    );
  }
}

/// ------------------------
/// TaskDialog: Add / Edit
/// ------------------------
class TaskDialog extends StatefulWidget {
  final String uid;
  final String? taskId;
  final String initialTitle;
  final String initialNote;
  final bool initialDone;

  const TaskDialog({
    required this.uid,
    this.taskId,
    this.initialTitle = '',
    this.initialNote = '',
    this.initialDone = false,
    super.key,
  });

  @override
  State<TaskDialog> createState() => _TaskDialogState();
}

class _TaskDialogState extends State<TaskDialog> {
  final _form = GlobalKey<FormState>();
  late String title;
  late String note;
  late bool done;
  bool saving = false;

  @override
  void initState() {
    super.initState();
    title = widget.initialTitle;
    note = widget.initialNote;
    done = widget.initialDone;
  }

  Future<void> save() async {
    if (!_form.currentState!.validate()) return;
    _form.currentState!.save();
    setState(() => saving = true);
    final col = FirebaseFirestore.instance.collection('tasks');
    try {
      if (widget.taskId == null) {
        await col.add({
          'uid': widget.uid,
          'title': title,
          'note': note,
          'done': done,
          'createdAt': FieldValue.serverTimestamp(),
        });
      } else {
        await col.doc(widget.taskId).update({
          'title': title,
          'note': note,
          'done': done,
          // don't change createdAt
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
      }
    } finally {
      if (mounted) setState(() => saving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.taskId == null ? 'Add task' : 'Edit task'),
      content: Form(
        key: _form,
        child: SingleChildScrollView(
          child: Column(mainAxisSize: MainAxisSize.min, children: [
            TextFormField(
              initialValue: title,
              decoration: const InputDecoration(labelText: 'Title'),
              validator: (v) => (v == null || v.trim().isEmpty) ? 'Enter a title' : null,
              onSaved: (v) => title = v!.trim(),
            ),
            TextFormField(
              initialValue: note,
              decoration: const InputDecoration(labelText: 'Note (optional)'),
              onSaved: (v) => note = v ?? '',
            ),
            CheckboxListTile(
              value: done,
              onChanged: (v) => setState(() => done = v ?? false),
              title: const Text('Mark as done'),
            ),
          ]),
        ),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
        ElevatedButton(onPressed: saving ? null : save, child: saving ? const CircularProgressIndicator.adaptive() : const Text('Save')),
      ],
    );
  }
}